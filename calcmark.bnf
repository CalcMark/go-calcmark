/*
 * CalcMark Language Specification (BNF Grammar)
 * Version: 2.0 (EBNF-driven with gocc)
 * 
 * ============================================================================
 * CANONICAL SPECIFICATION
 * ============================================================================
 * This file is the AUTHORITATIVE specification for the CalcMark language.
 * All implementations MUST conform to this specification.
 * 
 * IMPLEMENTATION STRATEGY:
 * - Lexical Section: Specifies token patterns (documentation + reference)
 * - Syntax Section: Generates parser via gocc
 * 
 * The Go reference implementation (go-calcmark) uses:
 * - Hand-written lexer (spec/lexer/*.go) implementing patterns below
 * - gocc-generated parser (from syntax section)
 * - Generated with: gocc -no_lexer calcmark.bnf
 * 
 * CONFORMANCE:
 * The Go lexer implementation MUST match this lexical specification exactly.
 * Comprehensive conformance tests validate zero drift from this specification.
 * Run: go test ./spec/lexer -tags=conformance
 * 
 * OTHER LANGUAGE IMPLEMENTATIONS:
 * Use this BNF as the canonical reference. The Go implementation (go-calcmark)
 * is the definitive reference for edge cases and Unicode handling.
 * See also: ENCODING_SPEC.md for emoji and Unicode rules.
 * 
 * ============================================================================
 */

/* ============================================================================
 * LEXICAL PART (Token Definitions)
 * ============================================================================ */

/* Whitespace (ignored) */
!whitespace : ' ' | '\t' | '\r' ;

/* Newline (significant - statement separator) */
newline : '\n' ;

/* Letters and digits */
_letter : 'a'-'z' | 'A'-'Z' ;
_upper : 'A'-'Z' ;
_digit : '0'-'9' ;

/* ============================================================================
 * LITERALS
 * ============================================================================ */

/* Number literals with multipliers - defined BEFORE plain number for longest-match priority
   Multipliers have NO SPACE between number and suffix (1.2M, 12k, 5%)
   Units MUST have a space after number (12 meters, 1.2 kg) */

/* Percentage: 5% = 0.05 */
number_percent : _digit { _digit | '_' } [ '.' { _digit } ] '%' ;

/* Thousands (k/K): 12k = 12000 */
number_k : _digit { _digit | '_' } [ '.' { _digit } ] 'k' ;
number_K : _digit { _digit | '_' } [ '.' { _digit } ] 'K' ;

/* Million: 1.2M = 1200000 */
number_M : _digit { _digit | '_' } [ '.' { _digit } ] 'M' ;

/* Billion: 5B = 5000000000 */
number_B : _digit { _digit | '_' } [ '.' { _digit } ] 'B' ;

/* Trillion: 2.5T = 2500000000000 */
number_T : _digit { _digit | '_' } [ '.' { _digit } ] 'T' ;

/* Scientific notation with positive exponent: 1.2e10 */
number_sci_e : _digit { _digit | '_' } [ '.' { _digit } ] 'e' '+' _digit { _digit } ;
number_sci_E : _digit { _digit | '_' } [ '.' { _digit } ] 'E' '+' _digit { _digit } ;

/* Scientific notation with negative exponent: 4.56e-7 */
number_sci_e_neg : _digit { _digit | '_' } [ '.' { _digit } ] 'e' '-' _digit { _digit } ;
number_sci_E_neg : _digit { _digit | '_' } [ '.' { _digit } ] 'E' '-' _digit { _digit } ;

/* Scientific notation without explicit sign: 1.2e5 (defaults to positive) */
number_sci_e_plain : _digit { _digit | '_' } [ '.' { _digit } ] 'e' _digit { _digit } ;
number_sci_E_plain : _digit { _digit | '_' } [ '.' { _digit } ] 'E' _digit { _digit } ;

/* Plain number moved to just before 'id' to ensure specific patterns match first */

/* Boolean literals */
bool_true  : 't' 'r' 'u' 'e' ;
bool_false : 'f' 'a' 'l' 's' 'e' ;
bool_yes   : 'y' 'e' 's' ;
bool_no    : 'n' 'o' ;

/* Currency symbols (prefix) */
currency_sym : '$' | '\u20AC' | '\u00A3' | '\u00A5' ;

/* Currency codes: 3 uppercase letters (ISO 4217 pattern) */
currency_code : _upper _upper _upper ;

/* Month names: both 3-letter and full names */
month_jan : 'J' 'a' 'n' | 'J' 'a' 'n' 'u' 'a' 'r' 'y' ;
month_feb : 'F' 'e' 'b' | 'F' 'e' 'b' 'r' 'u' 'a' 'r' 'y' ;
month_mar : 'M' 'a' 'r' | 'M' 'a' 'r' 'c' 'h' ;
month_apr : 'A' 'p' 'r' | 'A' 'p' 'r' 'i' 'l' ;
month_may : 'M' 'a' 'y' ;
month_jun : 'J' 'u' 'n' | 'J' 'u' 'n' 'e' ;
month_jul : 'J' 'u' 'l' | 'J' 'u' 'l' 'y' ;
month_aug : 'A' 'u' 'g' | 'A' 'u' 'g' 'u' 's' 't' ;
month_sep : 'S' 'e' 'p' | 'S' 'e' 'p' 't' 'e' 'm' 'b' 'e' 'r' ;
month_oct : 'O' 'c' 't' | 'O' 'c' 't' 'o' 'b' 'e' 'r' ;
month_nov : 'N' 'o' 'v' | 'N' 'o' 'v' 'e' 'm' 'b' 'e' 'r' ;
month_dec : 'D' 'e' 'c' | 'D' 'e' 'c' 'e' 'm' 'b' 'e' 'r' ;

/* Time units (singular and plural) */
time_day    : 'd' 'a' 'y' | 'd' 'a' 'y' 's' ;
time_hour   : 'h' 'o' 'u' 'r' | 'h' 'o' 'u' 'r' 's' ;
time_minute : 'm' 'i' 'n' 'u' 't' 'e' | 'm' 'i' 'n' 'u' 't' 'e' 's' ;
time_second : 's' 'e' 'c' 'o' 'n' 'd' | 's' 'e' 'c' 'o' 'n' 'd' 's' ;
time_week   : 'w' 'e' 'e' 'k' | 'w' 'e' 'e' 'k' 's' ;
time_month  : 'm' 'o' 'n' 't' 'h' | 'm' 'o' 'n' 't' 'h' 's' ;
time_year   : 'y' 'e' 'a' 'r' | 'y' 'e' 'a' 'r' 's' ;


/* ============================================================================
 * OPERATORS & KEYWORDS
 * ============================================================================ */

/* Arithmetic operators */
!comment : '/' '/' { . } '\n' ;

/* Operator tokens */
plus     : '+' ;
minus    : '-' ;
multiply : '*' ;
divide   : '/' ;
modulus  : '%' ;
caret    : '^' ;

/* Comparison operators */
eq  : '=' '=' ;
neq : '!' '=' ;
gt  : '>' ;
lt  : '<' ;
gte : '>' '=' ;
lte : '<' '=' ;

/* Assignment */
assign : '=' ;

/* Punctuation */
lparen : '(' ;
rparen : ')' ;
comma  : ',' ;
colon  : ':' ;

/* Keywords */
kw_convert   : 'c' 'o' 'n' 'v' 'e' 'r' 't' ;
kw_to        : 't' 'o' ;
kw_avg       : 'a' 'v' 'g' ;
kw_sqrt      : 's' 'q' 'r' 't' ;
kw_am        : 'A' 'M' | 'a' 'm' ;
kw_pm        : 'P' 'M' | 'p' 'm' ;
kw_pm        : 'P' 'M' | 'p' 'm' ;
kw_today     : 't' 'o' 'd' 'a' 'y' ;
kw_tomorrow  : 't' 'o' 'm' 'o' 'r' 'r' 'o' 'w' ;
kw_yesterday : 'y' 'e' 's' 't' 'e' 'r' 'd' 'a' 'y' ;
kw_now       : 'n' 'o' 'w' ;
kw_in        : 'i' 'n' ;
kw_utc       : 'U' 'T' 'C' | 'u' 't' 'c' ;

/* Plain number (fallback - defined LAST so specific multiplier patterns match first) */
number : _digit { _digit | '_' } [ '.' { _digit } ] ;

/* Identifier (variable names) */
id : ( _letter | '_' ) { _letter | _digit | '_' } ;

/* Unit names: must be at least 2 chars to avoid conflict with multipliers (k, M, B, T)
   Single-letter units like 'K' (Kelvin) must use uppercase after the parser combines them */
unit_name : _letter ( _letter | _digit | '/' | '^' ) { _letter | _digit | '/' | '^' } ;

/* ============================================================================
 * SYNTAX PART (Grammar Rules)
 * ============================================================================ */

<<
import (
    "strconv"
    "strings"
    "github.com/CalcMark/go-calcmark/spec/ast"
    "github.com/CalcMark/go-calcmark/spec/generated/token"
)

// expandNumberLiteral expands multiplier suffixes and scientific notation
// Examples: "12k" -> "12000", "1.2M" -> "1200000", "5%" -> "0.05", "1.2e10" -> "12000000000"
func expandNumberLiteral(lit string) string {
    if lit == "" {
        return lit
    }
    
    // Check for percentage (5% -> 0.05)
    if strings.HasSuffix(lit, "%") {
        base := strings.TrimSuffix(lit, "%")
        if val, err := strconv.ParseFloat(base, 64); err == nil {
            return strconv.FormatFloat(val/100.0, 'f', -1, 64)
        }
        return lit // fallback if parse fails
    }
    
    // Check for k/K multiplier (12k -> 12000)
    if strings.HasSuffix(lit, "k") || strings.HasSuffix(lit, "K") {
        base := lit[:len(lit)-1]
        if val, err := strconv.ParseFloat(base, 64); err == nil {
            return strconv.FormatFloat(val*1000, 'f', -1, 64)
        }
        return lit
    }
    
    // Check for M multiplier (1.2M -> 1200000)
    if strings.HasSuffix(lit, "M") {
        base := lit[:len(lit)-1]
        if val, err := strconv.ParseFloat(base, 64); err == nil {
            return strconv.FormatFloat(val*1000000, 'f', -1, 64)
        }
        return lit
    }
    
    // Check for B multiplier (5B -> 5000000000)
    if strings.HasSuffix(lit, "B") {
        base := lit[:len(lit)-1]
        if val, err := strconv.ParseFloat(base, 64); err == nil {
            return strconv.FormatFloat(val*1000000000, 'f', -1, 64)
        }
        return lit
    }
    
    // Check for T multiplier (2.5T -> 2500000000000)
    if strings.HasSuffix(lit, "T") {
        base := lit[:len(lit)-1]
        if val, err := strconv.ParseFloat(base, 64); err == nil {
            return strconv.FormatFloat(val*1000000000000, 'f', -1, 64)
        }
        return lit
    }
    
    // Check for scientific notation (1.2e10, 4.5e-7)
    // strconv.ParseFloat handles this natively
    if strings.Contains(strings.ToLower(lit), "e") {
        if val, err := strconv.ParseFloat(lit, 64); err == nil {
            return strconv.FormatFloat(val, 'f', -1, 64)
        }
        return lit
   }
    
    // No multiplier, return as-is
    return lit
}
>>

/* Program is a sequence of statements */
Program
    : StatementList
    ;

StatementList
    : empty                                 << []ast.Node{}, nil >>
    | StatementList Statement newline       << append($0.([]ast.Node), $1.(ast.Node)), nil >>
    | StatementList newline                 << $0, nil >>
    ;

/* Statement: assignment or expression */
Statement
    : Assignment                            << $0, nil >>
    | Expression                            << $0, nil >>
    ;

/* Assignment: identifier = expression */
Assignment
    : id assign Expression                  << &ast.Assignment{Name: string($0.(*token.Token).Lit), Value: $2.(ast.Node)}, nil >>
    ;

/* ============================================================================
 * EXPRESSIONS (Operator Precedence)
 * ============================================================================ */

/* Expression: comparison (lowest precedence) */
Expression
    : Comparison                            << &ast.Expression{Expr: $0.(ast.Node)}, nil >>
    ;

/* Comparison: ==, !=, <, >, <=, >= */
Comparison
    : Additive                              << $0, nil >>
    | Comparison eq Additive                << &ast.ComparisonOp{Operator: "==", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    | Comparison neq Additive               << &ast.ComparisonOp{Operator: "!=", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    | Comparison gt Additive                << &ast.ComparisonOp{Operator: ">", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    | Comparison lt Additive                << &ast.ComparisonOp{Operator: "<", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    | Comparison gte Additive               << &ast.ComparisonOp{Operator: ">=", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    | Comparison lte Additive               << &ast.ComparisonOp{Operator: "<=", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    ;

/* Additive: +, - */
Additive
    : Multiplicative                        << $0, nil >>
    | Additive plus Multiplicative          << &ast.BinaryOp{Operator: "+", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    | Additive minus Multiplicative         << &ast.BinaryOp{Operator: "-", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    ;

/* Multiplicative: *, /, % */
Multiplicative
    : Exponent                              << $0, nil >>
    | Multiplicative multiply Exponent      << &ast.BinaryOp{Operator: "*", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    | Multiplicative divide Exponent        << &ast.BinaryOp{Operator: "/", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    | Multiplicative modulus Exponent       << &ast.BinaryOp{Operator: "%", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    ;

/* Exponent: ^ (right-associative) */
Exponent
    : Unary                                 << $0, nil >>
    | Unary caret Exponent                  << &ast.BinaryOp{Operator: "^", Left: $0.(ast.Node), Right: $2.(ast.Node)}, nil >>
    ;

/* Unary: +, - */
Unary
    : Primary                               << $0, nil >>
    | plus Unary                            << &ast.UnaryOp{Operator: "+", Operand: $1.(ast.Node)}, nil >>
    | minus Unary                           << &ast.UnaryOp{Operator: "-", Operand: $1.(ast.Node)}, nil >>
    ;

/* ============================================================================
 * PRIMARY EXPRESSIONS
 * ============================================================================ */

Primary
    : currency_sym number                   << &ast.CurrencyLiteral{Symbol: string($0.(*token.Token).Lit), Value: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + string($1.(*token.Token).Lit)}, nil >>
    | number currency_code                  << &ast.CurrencyLiteral{Value: string($0.(*token.Token).Lit), Symbol: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + string($1.(*token.Token).Lit)}, nil >>
    | number unit_name                      << &ast.QuantityLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), Unit: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + " " + string($1.(*token.Token).Lit)}, nil >>
    | number id                             << &ast.QuantityLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), Unit: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + " " + string($1.(*token.Token).Lit)}, nil >>
    | Identifier unit_name                  << &ast.QuantityLiteral{Value: $0.(*ast.Identifier).Name, Unit: string($1.(*token.Token).Lit), SourceText: $0.(*ast.Identifier).Name + " " + string($1.(*token.Token).Lit)}, nil >>
    | Identifier id                         << &ast.QuantityLiteral{Value: $0.(*ast.Identifier).Name, Unit: string($1.(*token.Token).Lit), SourceText: $0.(*ast.Identifier).Name + " " + string($1.(*token.Token).Lit)}, nil >>
    | DateLiteral
    | DurationLiteral
    | BooleanLiteral
    | FunctionCall                          << $0, nil >>
    | ConvertExpression                     << $0, nil >>
    | Identifier                            << $0, nil >>
    | number                                << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_percent                        << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_k                              << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_K                              << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_M                              << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_B                              << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_T                              << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_sci_e                          << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_sci_E                          << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_sci_e_neg                      << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_sci_E_neg                      << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_sci_e_plain                    << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | number_sci_E_plain                    << &ast.NumberLiteral{Value: expandNumberLiteral(string($0.(*token.Token).Lit)), SourceText: string($0.(*token.Token).Lit)}, nil >>
    | lparen Expression rparen              << $1, nil >>
    ;

/* ============================================================================
 * LITERALS
 * ============================================================================ */


/* Quantity literal: number with unit */
QuantityLiteral
    : currency_sym number                   << &ast.CurrencyLiteral{Symbol: string($0.(*token.Token).Lit), Value: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + string($1.(*token.Token).Lit)}, nil >>
    | number currency_code                  << &ast.CurrencyLiteral{Value: string($0.(*token.Token).Lit), Symbol: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + string($1.(*token.Token).Lit)}, nil >>
    | number unit_name                      << &ast.QuantityLiteral{Value: string($0.(*token.Token).Lit), Unit: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + " " + string($1.(*token.Token).Lit)}, nil >>
    | number id                             << &ast.QuantityLiteral{Value: string($0.(*token.Token).Lit), Unit: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + " " + string($1.(*token.Token).Lit)}, nil >>
    | Identifier unit_name                  << &ast.QuantityLiteral{Value: $0.(*ast.Identifier).Name, Unit: string($1.(*token.Token).Lit), SourceText: $0.(*ast.Identifier).Name + " " + string($1.(*token.Token).Lit)}, nil >>
    | Identifier id                         << &ast.QuantityLiteral{Value: $0.(*ast.Identifier).Name, Unit: string($1.(*token.Token).Lit), SourceText: $0.(*ast.Identifier).Name + " " + string($1.(*token.Token).Lit)}, nil >>
    ;

/* Date literal: "Dec 25" or "December 25" */
DateLiteral
    : MonthName number MonthYear              << func() (interface{}, error) {
        year := string($2.(*token.Token).Lit)
        return &ast.DateLiteral{
            Month: string($0.(*token.Token).Lit), 
            Day: string($1.(*token.Token).Lit), 
            Year: &year,
            SourceText: string($0.(*token.Token).Lit) + " " + string($1.(*token.Token).Lit) + " " + year,
        }, nil
    }() >>
    | MonthName number                        << &ast.DateLiteral{
        Month: string($0.(*token.Token).Lit), 
        Day: string($1.(*token.Token).Lit), 
        Year: nil,
        SourceText: string($0.(*token.Token).Lit) + " " + string($1.(*token.Token).Lit),
    }, nil >>
    ;

MonthYear
    : number   << $0, nil >>
    ;

MonthName
    : month_jan                             << $0, nil >>
    | month_feb                             << $0, nil >>
    | month_mar                             << $0, nil >>
    | month_apr                             << $0, nil >>
    | month_may                             << $0, nil >>
    | month_jun                             << $0, nil >>
    | month_jul                             << $0, nil >>
    | month_aug                             << $0, nil >>
    | month_sep                             << $0, nil >>
    | month_oct                             << $0, nil >>
    | month_nov                             << $0, nil >>
    | month_dec                             << $0, nil >>
    ;

/* Duration literal: "5 days", "3 hours" */
DurationLiteral
    : number TimeUnit                       << &ast.DurationLiteral{Value: string($0.(*token.Token).Lit), Unit: string($1.(*token.Token).Lit), SourceText: string($0.(*token.Token).Lit) + " " + string($1.(*token.Token).Lit)}, nil >>
    ;

TimeUnit
    : time_day                              << $0, nil >>
    | time_hour                             << $0, nil >>
    | time_minute                           << $0, nil >>
    | time_second                           << $0, nil >>
    | time_week                             << $0, nil >>
    | time_month                            << $0, nil >>
    | time_year                             << $0, nil >>
    ;

/* Boolean literal */
BooleanLiteral
    : bool_true                             << &ast.BooleanLiteral{Value: "true"}, nil >>
    | bool_false                            << &ast.BooleanLiteral{Value: "false"}, nil >>
    | bool_yes                              << &ast.BooleanLiteral{Value: "yes"}, nil >>
    | bool_no                               << &ast.BooleanLiteral{Value: "no"}, nil >>
    ;

/* Identifier (variable reference) */
Identifier
    : id                                    << &ast.Identifier{Name: string($0.(*token.Token).Lit)}, nil >>
    ;

/* ============================================================================
 * FUNCTION CALLS
 * ============================================================================ */

FunctionCall
    : kw_avg lparen ArgumentList rparen     << &ast.FunctionCall{Name: "avg", Arguments: $2.([]ast.Node)}, nil >>
    | kw_sqrt lparen ArgumentList rparen    << &ast.FunctionCall{Name: "sqrt", Arguments: $2.([]ast.Node)}, nil >>
    ;

ArgumentList
    : empty                                 << []ast.Node{}, nil >>
    | NonEmptyArgumentList                  << $0, nil >>
    ;

NonEmptyArgumentList
    : Expression                            << []ast.Node{$0.(ast.Node)}, nil >>
    | NonEmptyArgumentList comma Expression << append($0.([]ast.Node), $2.(ast.Node)), nil >>
    ;

/* ============================================================================
 * NEW FEATURES
 * ============================================================================ */

/* Unit conversion: "convert 1 cup to ounces" */
ConvertExpression
    : kw_convert Expression kw_to UnitTarget << &ast.ConvertExpr{Value: $1.(ast.Node), TargetUnit: string($3.(*token.Token).Lit)}, nil >>
    | QuantityLiteral kw_in UnitTarget       << &ast.ConvertExpr{Value: $0.(ast.Node), TargetUnit: string($2.(*token.Token).Lit)}, nil >>
    ;

/* Target unit for conversion */
UnitTarget
    : id                                    << $0, nil >>
    | unit_name                             << $0, nil >>
    ;
